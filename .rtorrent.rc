# This is an example resource file for rTorrent. Copy to
# ~/.rtorrent.rc and enable/modify the options as needed. Remember to
# uncomment the options you wish to enable.

# Preallocate files; reduces defragmentation on filesystems.
system.file_allocate.set = yes

# Maximum and minimum number of peers to connect to per torrent.
#min_peers = 50
max_peers = 300

# Same as above but for seeding completed torrents (-1 = same as downloading)
#min_peers_seed = 3
max_peers_seed = 3

# Maximum number of simultanious uploads per torrent.
max_uploads = 3

# Global upload and download rate in KiB. "0" for unlimited.
download_rate = 300
upload_rate = 30

# Default directory to save the downloaded torrents.
directory = /home/crab/download

# Default session directory. Make sure you don't run multiple instance
# of rtorrent using the same session directory. Perhaps using a
# relative path?
session = /home/crab/tmp/rt-session

# Watch a directory for new torrents, and stop those that have been
# deleted.
schedule = watch_directory,5,5,load_start=/home/crab/download/torrents/*.torrent
schedule = untied_directory,5,5,stop_untied=
schedule = tied_directory,5,5,start_tied=

# Close torrents when diskspace is low.
#schedule = low_diskspace,5,60,close_low_diskspace=100M

# Enable the default ratio group.
ratio.enable=

# Change the limits, the defaults should be sufficient.
ratio.min.set=100
ratio.max.set=300
ratio.upload.set=100M

# Changing the command triggered when the ratio is reached.
system.method.set = group.seeding.ratio.command, d.close=, d.erase=

# The ip address reported to the tracker.
#ip = 127.0.0.1
#ip = rakshasa.no

# The ip address the listening socket and outgoing connections is
# bound to.
#bind = 127.0.0.1
#bind = rakshasa.no

# Port range to use for listening.
port_range = 38900-39990

# Start opening ports at a random position within the port range.
port_random = yes

# Check hash for finished torrents. Might be usefull until the bug is
# fixed that causes lack of diskspace not to be properly reported.
check_hash = yes

# Set whetever the client should try to connect to UDP trackers.
#use_udp_trackers = yes

# Alternative calls to bind and ip that should handle dynamic ip's.
#schedule = ip_tick,0,1800,ip=rakshasa
#schedule = bind_tick,0,1800,bind=rakshasa

# Encryption options, set to none (default) or any combination of the following:
# allow_incoming, try_outgoing, require, require_RC4, enable_retry, prefer_plaintext
#
# The example value allows incoming encrypted connections, starts unencrypted
# outgoing connections but retries with encryption if they fail, preferring
# plaintext to RC4 encryption after the encrypted handshake
#
encryption = allow_incoming,try_outgoing,enable_retry

# Enable DHT support for trackerless torrents or when all trackers are down.
# May be set to "disable" (completely disable DHT), "off" (do not start DHT),
# "auto" (start and stop DHT as needed), or "on" (start DHT immediately).
# The default is "off". For DHT to work, a session directory must be defined.
# 
dht = on

# UDP port to use for DHT. 
# 
dht_port = 38838

# Enable peer exchange (for torrents not marked private)
#
peer_exchange = yes

#
# Do not modify the following parameters unless you know what you're doing.
#

# Hash read-ahead controls how many MB to request the kernel to read
# ahead. If the value is too low the disk may not be fully utilized,
# while if too high the kernel might not be able to keep the read
# pages in memory thus end up trashing.
#hash_read_ahead = 10

# Interval between attempts to check the hash, in milliseconds.
#hash_interval = 100

# Number of attempts to check the hash while using the mincore status,
# before forcing. Overworked systems might need lower values to get a
# decent hash checking rate.
#hash_max_tries = 10

encoding_list = utf8

################################################################################

# Set colors using the options below in .rtorrent.rc:
# Options: done_fg_color, done_bg_color, active_fg_color, active_bg_color
# Colors: 0 = black 1 = red 2 = green 3 = yellow 4 = blue 5 = magenta 6 = cyan 7 = white
# Example: done_fg_color = 1
#
################################################################################
# The filter files are the ones from bluetack.co.uk. Multiple files can be used.
# Overlapping ranges are merged automatically. Both incoming and outgoing
# connections are checked against the filter. Exclusions are not supported, so
# connection to/from IPs in all the loaded ranges will be disallowed and dropped.
#
# Include "ip_filter=" directive in .rtorrent.rc. For example mine looks like:
#
### ip_filter=ipfilter/level1,ipfilter/level2,ipfilter/bogon,ipfilter/dshield,ipfilter/Microsoft,ipfilter/templist
#
# It is probably a good idea to reload files once in a while, so you can also include "reload_ip_filter" directive on schedule to refresh the filter. The same files named in "ip_filter" will be reloaded.
### schedule = filter,18:30:00,24:00:00,reload_ip_filter=
#
# http://libtorrent.rakshasa.no/ticket/239
#
#################################################################################
# Automated handling of leechers and other uncooperative peers.
#
# Adds the following commands:
# d.snub_leechers=snub_ratio,unsnub_ratio,min_transfer
# Snub peers (i.e. stop uploading to them) who download far more than they
# upload. They're snubbed when their ratio exceeds the snub_ratio,
# and unsnubbed when they drop below the unsnub_ratio again. For example,
# a snub_ratio of 10 means the peer gets snubbed if we send more than
# ten times the amount that we've received from them. Don't set
# snub_ratio too low, a value of 5-10 seems to work best. The first
# min_transfer bytes is uploaded for "free" without snubbing.
# d.unsnub_peers=
# Unsnub all snubbed peers, e.g. for use when the download is finished
# and we no longer have anything we want to download anyway.
# d.ban_slow_peers=min_seeds,min_rate,amount1,time1[,amount2,time2[,...]]
# Ban peers whose upload is too slow, for instance hacked peers, badly
# throttled connections or ISPs with excessive bandwidth shaping. This
# clears up the peer list and allows connecting to better peers, to
# prevent staying connected forever to peers that never send data.
# Always keeps at least the set min_peers for the download, and at least
# as many seeds as min_seeds as well as all peers currently sending at a
# rate of min_rate or above. A peer is too slow if after time1 has elapsed,
# it has sent less than amount1, or amount2 after time2, etc.
# d.unban_peers=
# Unban all peers, including those banned manually with shift-B.
#
# Note that peers marked as friends (if you have applied that patch) will
# never be snubbed or banned by these commands.
#
# There are also global "snub_leechers" and "ban_slow_peers" commands which
# take the same arguments and apply them to all unfinished downloads (except
# those set to ignore commands).
#
# Note that the commands usually don't work well for poorly seeded torrents
# or those being seeded initially, then unreasonably many peers will be
# snubbed/banned. You should set the ignore_commands flag for such downloads,
# or avoid using the global commands and instead only apply the
# download-specific commands to the particular downloads that need them (e.g.
# using d.multicall on a custom view that only contains appropriate downloads).
#
# Example: (this seems to work fine for a typical ADSL line)
# schedule = snub_leechers,120,120,"snub_leechers=10,5,1M"
# schedule = ban_slow_peers,120,120,"ban_slow_peers=5,2K,64K,5,128K,10,1M,30"
# on_finished = unban,"d.unban_peers="
# on_finished = unsnub,"d.unsnub_peers="
#
# Snub peers after sending 1MB to them if they don't upload at least 1/10th in return.
# Unsnub them when they upload to a ratio of 1/5th, and when the download finishes.
#
# Ban peers after 5 minutes unless they've uploaded less than 64KB, after 10 min
# and less than 128 K or after 30 min and under 1MB upload. Keep at least 5 seeds,
# and all peers currently uploading at 2KB/s or faster.
# Unban peers when the download finishes.
